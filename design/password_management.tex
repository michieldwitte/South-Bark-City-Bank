\documentclass[10pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Sander Demeester}
\title{Password storage crypto-design.}
\begin{document}
Om onze wachtwoorden veilig op te slaan maken we gebruik van het volgende algoritme.
\begin{subsection}{Client-side}
We nemen de username $U_{1}$ en password $P_{1}$ en concateren die tot een string $S_{1}$.
Daarna gaan we op de client bcrypt gebruiken met als input $S_{1}$ als salt gebruiken we een SHA-512 hash van deze string, dit is niet de meeste veilig salt, maar omdat we op de server toch opnieuw zullen hashen maakt het hier niet zoveel uit wat we gebruiken. We willen hier enkel een kost introduceren.
De output hiervan noemen we $B_{1}$. Daarna nemen we een hash $H()$ van $UID = H(B_{1} || P_{1}$, deze hash is onze unieke ID. Deze unieke ID gaat samen met onze username $U_{1}$ terug naar de server. De reden dat we hier ook onze username mee terug sturen is zodat we weten dat weten aan welke username deze unieke ID is gekoppeld. 

De hashing algoritme in gebruik is SHA-256. 
\end{subsection}
\begin{subsection}{Server-side}
Daarna, op de server ontvangen we het koppel $(U_{1},UID)$. Op de server kant genereren we een 256-bit random salt (dit is uniek per user) en slaan we op samen de user zijn information. Daarna maken we gebruik van PBKDF2, de input van PBKDF2 is de salt, het paar $(U_{1},UID)$ en een werk last. De output hiervan slaan we op in de databank. 
\end{subsection}
\end{document}