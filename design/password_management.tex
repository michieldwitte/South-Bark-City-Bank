\documentclass[10pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\author{Sander Demeester}
\title{Password storage crypto-design.}
\begin{document}
\begin{subsection}{Client-side}
$U_1$ = Username
$P_1$ = Password
We maken gebruik van scrypt om deze informatie client-side te hashen. 
$S_{1} = scrypt((P_1 || U_1), H(P_1 || U_1),4096)$.
Daarna versturen we het koppel $(U_1,S_1)$ naar de server.
\end{subsection}
\begin{subsection}{Server-side}
Op de server ontvangen we $(U_1,S_1)$.
Het eerste wat we doen is een random salt $S_2$ maken. Deze salt zullen we samen met $S_1$ in een PBKDF2 functie steken om een AES-key mee te maken. Het punt van deze AES-key is om andere informatie te beveiligen, nl de hash van ons wachtwoord en de sequentie key voor ons OTP systeem. $K_1 = PBKDF2(S_1,S_2)$. 
Als dit de eerste keer is dat een account word gemaakt zal hier nu ook een seqentie key worden aangemaakt die zal worden gebruikt als input voor onze OTP. Er zal een 64bit counter zijn die hier ook zal worden opgeslagen. Daarnaast maken we nu nog een salt $S_3$ die samen met $S_1$ zal worden gehased en zal worden opgeslagen geencrypteerd in de databank. 
Volgende tabel maakt dit allemaal wat duidelijker.
\begin{tabular}{|c|c|}
\hline 
Encrypteerd & Plain-text \\ 
\hline 
Hash($S_1$,$S_3$) & $U_1$ \\ 
\hline 
Seqentie string & $S_2$ \\ 
\hline 
Counter & • \\ 
\hline 
Andere bank info & • \\ 
\hline 
• & • \\ 
\hline 
\end{tabular} 
\end{subsection}
\begin{subsection}{Het verantwoorden van mijn keuze}
Het is belangrijk op te merken dat de data die we op de server bijhouden enkel kan worden gedecrypteerd als de user is ingelogd. We hebben namelijk $S_1$ nodig om de AES key terug te kunnen krijgen. De reden dat we salt $S_2$ nodig hebben is zodat als de user controle verliest over $S_1$ (dit kan enkel als een virus in de user zijn browser zit, of de SSL verbinding word gesnift) dan kan de aanvaller nog altijd niet aan de user zijn persoonlijke info want hij heeft geen bezit van $S_2$ die uniek is per user. 
De reden dat ik heb gekozen voor scrypt is omdat het onmogelijk is dit te paraliseren. Het maakt gebruik van een memory-hard algoritme. Het gebruik hier van GPU hier geen 0 zin.
Info:www.tarsnap.com/scrypt/scrypt.pdf
Voo
\end{document}