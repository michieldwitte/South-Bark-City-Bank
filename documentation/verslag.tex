\documentclass[11pt]{article}
\usepackage{fullpage}

\usepackage{hyperref}
\setlength{\parindent}{0cm}
%Gummi|061|=)
\title{\textbf{Beveiliging voor online banking}}
\author{Sander Demeester\\
		Michiel De Witte\\
		Stef Trenson}
\date{}
\begin{document}

\maketitle

\section{Inleiding}
Online bankieren en bekijken van Financi\"ele informatie op een computer is onmisbaar in de digitale wereld van vandaag. Goeie beveiligingsmechanisme zijn dus van een cruciaal belang voor deze system. 

\section{Beveiligingseisen}
\label{sec:bev_eis}
\begin{itemize}
\item Privacy (tussen de gebruikers, de bank zelf moet kunnen verificeren dat het echt wel de juiste gebruiker is). De gebruiker moet kunnen vertrouwen dat de bank zijn/haar informatie geheim houd. Het limeteren van wie in de bank aan welke informatie kan is hier van groot belang.
\item Vertrouwelijkheid (encryptie van informatie)
\item Verificatie (is de informatie wel correct?)
\item Authenticatie (praat je wel met de juiste server, praat de server wel met wie hij denkt te praten?)
\item Worden betalingen en transacties correct uitgevoerd. Is er niet repudiation?
\item Systeem vertrouwen/persoonvertrouwen (vertrouw je iedereen die werkt in uw bank met uw gegevens).
\item Cryptografische functies moeten veilig zijn. Maar correct gebruik in het grotere systeem is belangrijker.

\end{itemize}
We maken het onderscheid tussen 2 belangrijke zaken. nl: 
\begin{itemize}
\item vertrouwelijkheid van gegevens
\item Authenticatie van entiteiten met een zoon hoog mogelijke zekerheid van identificatie van beide actoren (server,client).
\end{itemize}
\subsection{Beveiliging aanvalsvectoren}
%TODO: Hier bekijken we het threat model. Waar beschermen we tegen en vooral waar beschermen we niet tegen
We analyseren het \" threat model \" van ons systeem. Aan de hand van onze applicatie-eisen zullen we een threat model opstellen en proberen mogelijke aanvalsvectoren te identificeren. We herkennen dat zoiets als "perfecte beveiling niet bestaat". Er zijn altijd meerdere partijen betrokken bij het systeem en foutief gedrag van een partij kan leiden tot een gecompromitteerd systeem. Ons doel is een voldoende beveiling te garanderen voor onze resources.
\subsubsection{Authenticatie van entititen op applicatie niveau}
%TODO: bespreken wachtwoorden en andere mechanismes voor authenticatie en verificatie
%Opnemen van multifactor authenticatie en hun nut (something you are, something you know, something you have).
Waarom wachtwoorden? Wat bewijzen wachtwoorden? Waarom zijn wachtwoorden een zwake vorm van authenticatie? Het belangt van OTP en het belang van een niet statische 2de factor.

\subsubsection{Denial of Service}
%TODO: bespreken van DoS aanvallen op server

\subsubsection{Vertrouwelijkheid op applicatie niveau}
%TODO: bespreken van encryptie in de databank. 
Bespreken van bcrypt, scrypt. Memory hard problems. Waarom encrypteren op de client en op de server kant (omdat de bank nooit zelf zou beschikken over het originele wachtwoord dat de gebruiker elder zou hergebruiken).

\subsubsection{Vertrouwelijkheid op transport niveau}
%TODO: bespreken van TLS/SSL en het probleem met MITM en CBC BEAST-attack op ssl3.0/tls1.0 (opgelost in TLS1.1 maar geen goeie adoptie (gebruik van RC4 is hier een oplossing)
% bespreken van compressie probleem bij TLS (Compression Ratio Info-leak Made Easy attack)
TLS/SSL is de manier om vandaag vertrouwelijkheid te realiseren op transport/netwerk laag. We kunnen 2 groepen van problemen onderscheiden.

\begin{itemize}
\item Menselijke fouten
\item Implementatie/algoritmische fouten
\end{itemize}

Menselijke fouten is het negeren van browser waarschuwingen en phishing emails niet te negeren.
Implementatie/algoritmische fouten zijn fouten die geintroduceerd zijn door het beveiligingssysteem zelf of door slechte configuratie van het systeem. Zoals het gebruik van md5 voor digital signatures bij ssl/tls (md5 second-preimage resistance is gebroken).
Daarnaast is er een probleem bij het gebruikt van CBC-encryption mode bij ssl3.0/tls1.0. CBC mode in ssl2.0/tls1.0 maakt gebruik van chained initialization vectors die het mogelijk maken een MITM aanval uit te voeren door een blockwise chosen-boundary aaval uit te voeren. Het resultaat is dat HTTP headers leesbaar worden en een deel vertrouwelijkheid verloren gaat. \\

Daarnaast is het mogelijk voor een hacker om session-hijacking te doen op een ssl/tls verbinding als de verbinding compressie gebruikt. Bij deze aanval gaat niet enkel de vertrouwelijkheid verloren maar ook de authenticiteit van beide eindpunten is verloren.

\subsection{Mechanismes om te voldoen aan Beveiligingseisen}
op welke manieren probeert ons syteem te voldoen aan de beveiligingseisen die worden gesteld.

\subsubsection{Multi-factor authentication}
Dit is de notie van \"something you have and something you know \". 
Het traditioneel gebruik van wachtwoorden is niet voldoende. Wachtwoorden worden hergebruikt en zijn een single point of failure voor een authenticatie systeem. We moeten dus gebruik maken van een extra factor waar beide entititen (zowel de bank als de klant) weet van moeten hebben. Het is belangrijk dat deze factor onafhankelijk is van het systeem en niet berust op de gebruiker om iets te moeten onthouden (zoals een wachtwoord). Deze werkwijze neemt meestal de vorm aan van een hardware token. Omdat het niet mogelijk was zelf hardware tokens te maken hebben we een android app ontworpen om een deel van deze functionaliteit te simuleren.
\section{Architectuur en Implementatie}
\subsection{Architectuur}
Gekoppeld aan het gebruik van het systeem is een android app die we gebruiken voor multifactor authenticatie in de vorm van een OTP systeem. Dit is niet ideaal omdat het geen dedecated hardware is en er de mogelijheid is dat de gebruiker controle verliest over zijn smartphone.\\

De android app maakt het ook mogelijk om aan bericht authenticatie te doen in de vorm van een HMAC die we zullen gebruiken als verificatie voor een transactie (we gaan hier later verder op in).

Tijdens het opzetten van een account zal de gebruiker persoonlijke informatie aanbieden aan de bank (via een web formulier), deze informatie bevat onder meer een door de gebruiker gekozen wachtwoord en persoonlijke informatie zoals zijn email adres en woonplaats.\\

Voor deze informatie naar de server wordt overbracht zal op de gebruiker zijn computer het wachtwoord worden versterkt. We maken gebruik van een password based key derivation function \ref{sec:pbkdf2} om het wachtwoord te verlengen naar 256 bits (de salt is de hash van het zelfde wachtwoord). 

We doen dit voor de volgende redenen.
\begin{itemize}
\item De server kent nooit de gebruiker zijn plain text wachtwoord. 
\item De server zal deze 256 bits gebruiken om het shared key die op de server zal worden aangemaakt te encrypteren.
\end{itemize}

Deze informatie zal naar de server worden verzonden over een vertrouwlijk kanaal (ssl/tls). 
Daarna maakt de server een \emph{shared secret} aan van 512 bits met fortuna \ref{sec:fortuna}. Dit shared secret word in de database opgeslagen samen met de andere informatie en het default saldo van de gebruiker. Er is een belangrijk verschil in hoe deze informatie word opgeslagen. Het \emph{shared secret} word eerst ge\"encrpteerd met het wachtwoord dat de server ontvangt (de 256 bits output van de PBKDF2 functie). De reden hiervoor is dat de server enkel toegang mag hebben tot een plain text versie van het \emph{shared secret} als de gebruiker aanwezig is (nl, is ingelogd in het systeem). De andere informatie moet beschikbaar zijn ookal is de gebruiker niet aanwezig, de bank moet deze gegevens kunnen beheren.

Password storage op de server wordt gedaan door het password eerst te onderwerpen aan bcrypt \ref{sec:bcrypt}. Bcrypt is een key derivation functie die is ontworpen met 2 doelstellingen.
\begin{itemize}
\item Introduceren van een salt om rainbow tables tegen te gaan.
\item Meerdere rondes van encryptie met blowfish. Bcrypt maakt gebruik van een licht aangepaste key setup. Zowel het bericht (het wachtwoord) en de salt worden gebruikt om subkeys te maken. Het doel hiervan is om de hoeveel rekenkracht nodig om 1 wachtwoord te bepalen te doen stijgen. 
\end{itemize}
De reden dat we zowel hashen op de server als op de computer van de gerbuiker is omdat op deze manier server kan garanderen dat het nooit het wachtwoord van de gebruiker kent. De bank beschermt zich op deze manier tegen zichzelf. Daarna worden de \"plain text\" wachtwoorden ook nog eens veilig opgeslagen op de server met bcrypt. Dit maakt het \emph{computational invisible} om de wachtwoorden te brute forcen.

Om een gebruiker uniek te identifieren wordt een unique id aangemaakt die met de gebruiker zijn account wordt geassocieerd. Dit zal, samen met het gekozen wachtwoord worden gebruikt als één authenticatie factor van het multifactor authenticatie proces.
	
\subsubsection{Shared secret}
Het shared secret heeft een centrale rol in ons systeem. Het wordt gebruikt om veilig in te loggen en om transactie te veriferen en authenticeren. Het shared secret is een random string van 512 bits dat wordt aangemaakt met fortuna \ref{sec:fortuna}. 
Het \emph{shared secret} wordt gedeelde tussen de gebruiker en de server. De manier waarop we dit communiceren met de gebruiker is door het \emph{shared secret} te encoderen als een QR-code en de smartphone app deze code te laten inlezen.\\
%TODO: michiel: beschrijf hoe de app die opslaat. 
Het \emph{shared secret} wordt op 2 manieren gebruikt. \\
Tijdens het inloggen moet de gebruiker zijn ID en gekozen wachtwoord ingeven. Het wachtwoord word op de client kant terug door een PBKDF2 transformatie gestuurd en verzonden naar de server. Eerst wordt gecontroleerd of het wachtwoord correct is door bcrypt te gebruiken en te vergelijken met het resulaat in de databank. Als de verificatie slaagt zal het origineel verzonden wachtwoord (de output van de PBKDF2 functie op de client) worden gebruikt om het \emph{shared secret} te decrypteren in de databank. Voor de rest van de sessie zal een  plain text versie van het \emph{shared secret} beschikbaar zijn op de server.

Op dit moment beschikken zowel de server als de gebruiker over het shared secret. De server voert een \emph{challenge and response} protocol uit om te controleren of de gebruiker beschikt over het correcte \emph{shared secret}.\\

\subsubsection{Challenge and response}
De manier waarop de server dit doet is de volgende, de server genereerd 8 random bytes gebruik makende van fortuna \ref{sec:fortuna}. Deze 8 random bytes worden in de vorm van een QR-code aan de client gepresenteerd. De client gebruikt de smartphone app om deze 8 random bytes te verwerken op de volgende manier.\\

De 8 random bytes worden ge-xored met de unix time / 1000L (we delen hier door 1000L) om een tijd raam van 30 seconden te introduceren waarin de response geldig zal zijn.\\

We merken op dat de response afhankelijk is van de tijd (niet de challenge). De reden hiervoor is omdat we vanaf een response is gemaakt deze een vorm van informatie is voor de huidige inlog procedure. Voordat de response is gemaakt  heeft de challenge geen waarde.\\

Daarna gebruiken we een Time-Based One-Time password Algorithm \ref{sec:totp} met als key het \emph{shared secret} en als tijd factor de 8 bytes ge-xored met de unix time. We herkennen het probleem dat ongeveer de 32 minst significaten bits zullen worden beinvloed door de tijd. Dit is niet echt een probleem omdat de overige bits ook random zijn.

De gebruiker voert het time based one time password algoritme uit met als key het \emph{shared secret} en als message de 8 bytes. Het resultaat is een token van 8 digits lang die afhankelijk is van de server zijn \emph{challenge}, een tijds factor en het \emph{shared secret}. De gebruiker stuurt dit terug naar de server. De server beschikt over de zelfde informatie op de exacte tijd na, maar is instaat op binnen het tijds venster te controleren dat de response geldig is. We herkennen het probleem dat de tijd lichtjes kan verschillen. De server houdt hier rekening mee.\\

De tweede manier waarop het \emph{shared secret} wordt gebruikt is tijdens het authenticeren en het veriferen van een transactie.

\subsubsection{Verifictie en authenticatie van een transactie}
Op het moment dat de gebruiker een transactie wil uitvoeren zal de server een hash-based message authenticatie code bepalen van de transactie (HMAC). Op dit moment is de gebruiker ingelogd en heeft het systeem toegang tot de plain text versie van het \emph{shared secret}. Dit \emph{shared secret} zal als key worden gebruikt (herinner dat het \emph{shared secret} 512 bits lang is). Als key voor de HMAC bericht word alle informatie in de transactie samen beschouwd (inclusief de tijd op het moment van de transactie zelf). \\

Het is enkel mogelijk om een geldige HMAC te bepalen van een transactie als de gebruiker is ingelogd en zijn \emph{shared secret} is gedecrypteerd.\\

Deze HMAC kan later worden gebruikt als verificatie van de transactie, nl: "Het is enkel mogelijk da deze HMAC is gemaakt met een plain text versie van het \emph{shared secret}". Dit impliceerd dat de maker van de HMAC kennis moet hebben van het \emph{shared secret} in plain text, de bank heeft hiertoe enkel toegang als de gebruiker is ingelogd in het systeem.\\


We gebruiken hier een HMAC in tegenstelling tot een gewone bericht authenticate om de length extension attack te voorkomen.\\

Eenmaal de HMAC is berekend nemen we de 64 minst significante bits en maken terug een QR-code en voeren we opnieuw het bovenstaande challenge en reponse protocol uit. Dit resulteerde in transactie authenticatie. Dit bewijst enkel dat op het huidige moment een persoon met kennis van het \emph{shared secret} en de challenge (de 64 minst significante bits) deze transactie goedkeurd, het systeem zal enkel een transactie uitvoeren als is voldaan aan de response code. slaan we ook op in de databank samen met de HMAC.
\subsubsection{Account security assets}
Inloggen bestaat uit 2 fases. Het aanbieden van het ID en wachtwoord en het uitvoeren van de challenge en response procedure. Het systeem zal pas een melding geven dat de login foutief was na dat de gebruiker een response code heeft ingeven, ookal is de combinatie van ID en wachtwoord foutief. Dit is om geef informatie te lekken of welk deel van de login procedure foutief is.\\

Bij drie foute login pogingen moet de gebruiker contact met de bank opnemen om zijn account te resetten. Dit houd in dat een nieuwe \emph{shared secret} zal moeten worden aangemaakt.
\subsection{Implementatie}
\subsubsection{Random events}
\subsubsection{Fortuna}
\label{sec:fortuna}
Implementatie details over fortuna

\subsubsection{Time-based One-time Password Algorithm}
\label{sec:totp}
We maken gebruik van het TOTP protocol beschreven in RFC 6238.

\subsubsection{PBBKDF2}
\label{sec:pbkdf2}
Informatie over PBKDF2

\subsubsection{Bericht authenticatie}
\label{sec:mac}

\subsubsection{Account beveiliging}
\label{sec:bev}
3 keer inloggen
\section{Problemen}
\subsection{Algemene problemen en hun oplossingen}
De denkwijze die we tijdens dit project handeerde is die van "Professional Paranoia". We gaan er ook vanuit dat de gebruiker zijn computer gecompromitteerd is en de aanvaller alles kan zien.

\subsubsection{Inlog procedure}
Het is enkel mogelijk om in te loggen als de persoon beschikt over de correcte ID en het gekozen wachtwoord. Het is niet mogelijk om te ssl/tls verbindingen af te luisteren wegens gebruik van STS (strict-transport-security). Zowel de gebruiker als de bank beschikken over het ID, maar enkel de gebruiker beschikt over het gekozen wachtwoord (de bank heeft enkel een geencrypteerde versie van het wachtwoord en krijgt nooit de plain-text versie te zien). Dit is de \"something you know\"-factor.

Daarnaast hebben we ook nog de \"something you have\"-factor, nl het \emph{shared secret}. Enkel de gebruiker beschikt over deze informatie in de android app. We herkennen het probleem dat de gebruiker deze informatie kan verliezen. Maar de app beschikt enkel over het \emph{shared secret}, niet over de gebruiker zijn ID of wachtwoord.\\

Er kan eventueel het probleem zijn dat de gebruiker zijn machine gecompromitteerd is. Wat wil zeggen dat het ID en wachtwoord gekend zijn. Het is voor een aanvaler niet mogelijk om informatie over het \emph{shared secret} te halen uit het response van de gebruiker. Ook kan deze response niet worden herbruikt omdat van zodra de response gemaakt word ze waarde krijgt in het protocol en de versheid beschermd word door de tijd.

\subsubsection{Authenticatie en verificatie van transacties}
De problemen hier verdelen we in 2 groepen.
\begin{itemize}
\item Verificatie in de huidige tijd en op latere tijdstippen.
\item Authenticatie in de huidige tijd.
\end{itemize}
Verificatie in de hudige tijd gebeurd door een combinatie van 2 dingen, nl: De gebruiker is ingelogd en de server heeft toegang tot het \emph{shared secret} en de gebruiker kan bewijzen dat hij toegang heeft tot het zelfde \emph{shared secret} door terug de \emph{challenge response} procedure te doorlopen met de 64 minst significante bits van de HMAC. Als de server de response niet kan veriferen kan de transactie niet doorgaan. Deze 2 eisen zijn voldoende voor authenticatie en verificatie in de huidige tijd. \\

Verificatie van een transactie op een later tijdstip kan worden gedaan als de gebruiker het \emph{shared secret} op de server decrypteerd. En enkel de gebruiker kon deze transactie doen want enkel hij beschikt over het wachtwoord om de bank toegang te geven zijn \emph{shared secret}. Daarnaast moeten alle stappen van het systeem worden uitgevoerd alsvoor het mogelijk is een transactie uit te voeren. Dus moet authenticatie ooit hebben plaats gevonden.
\section{Conclusie en observaties}
We bekijken alle belangrijke observaties en tonen aan hoe ons systeem voldoet aan de gestelde beveilingseisen in \ref{sec:bev_eis}.
\ de rechtmatige gebruiker te zijn. Ofwel is de 
If you are wondering where your old default text is; it has been stored as a template. The template menu can be used to access and restore it. 

\bibliography{information_security_bibtex}{}
\bibliographystyle{plain}
\end{document}
