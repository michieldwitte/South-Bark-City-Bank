\documentclass[10pt,a4paper]{report}
\usepackage[latin1]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}
\usepackage{amssymb}
\author{Sander Demeester}
\title{OTP-crypto design}
\begin{document}
\begin{section}*{HMAC-based one-time password algoritme}
\url{http://tools.ietf.org/html/rfc4226}
\href{http://tools.ietf.org/html/rfc4226}{HOTP: An HMAC-Based One-Time Password Algorithm}\\
\url{http://tools.ietf.org/html/rfc6238}
\href{http://tools.ietf.org/html/rfc6238}{TOTP: Time-Based One-Time Password Algorithm}
\section*{HOTP}
HMAC based one-time password algoritme voor 2-factor authenticatie.\\
De RFC voor dit algoritme vertelt ons dat we SHA1 moeten gebruiken. Maar SHA1 heeft technische problemen, nl er kunnen collisions worden gevonden in $2^69$ operaties. Dit is argumenteerbaar of het echt een probleem zou zijn omdat de counter die hier zou worden gebruikt blijft optellen. Dus voorspellen waar de counter zou zijn is moeilijk. Let wel op, moeilijk. Niet onmogelijk. 
\subsection*{Definitie}
\begin{itemize}
\item $K$ is een \emph{secret key}.
\item $C$ is een \emph{counter}.
\item HMAC($K$,$C$) is een HMAC functie, in rfc4226 staat vermeld dat hier SHA1 moet worden gebruikt. 
\item Selecteer 4 bytes van de resulterende HMAC. We noemen deze functie $T()$. De 4-bytes moeten altijd op de zelde manier worden gekozen.
\item HOTP($K$,$C$) = $T($HMAC($K$,$C$)) \& 0x7FFFFFFF. De reden dat we hier een AND-mask toepassen is om de MSB weg te werken enzo meer compatibel te zijn tussen verschillende processen.
\end{itemize}
\subsection*{Voorwaarden}
Zoals vermeld moet er worden gebruikt gemaakt van een \emph{secret key}. Deze key moet gekend zijn door de client als door de server, alsook de counter moet door beide partijen gekend zijn. De counter moet nooit worden gecommuniceerd met de server. De \emph{secert key} wel.\\
\end{section}
\section*{TOTP}
Time-based one-time password algoritme, dit is een extentie van het HOTP, het grote verschil met HTOP is dat hier de "tijd" een factor speelt.\\

Een ander verschil hier is dat de standaard RFC-6238 beschrijft dat ook andere hashing algoritmes mogen worden gebruikt, nl de algoritmes uit de SHA2-familie. Die om dit moment betere hashing algoritmes zijn.
\subsection*{Definitie}
Citatie uit de rfc: " 
Basically, we define TOTP as TOTP = HOTP(K, T), where T is an integer
and represents the number of time steps between the initial counter
time T0 and the current Unix time."
\begin{itemize}
\item $K$ is een \emph{shared secret key}
\item $M$, we defineren $M$ als de huidige unix-time met een fout marge.
\item TOTP = HOTP($K$,$M$)
\end{itemize}
Beide definities van TOTP en HOTP zijn volgens de definitie van de bovenstaande RFC samen met voorbeeld code in java. Een implementatie van een HMAC in python kan je vinden in deze github repo onder "voorbeeld_code".
\end{document}